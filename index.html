<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>random pixel grid deep zoom</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for ultra-minimalist, black-on-white theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: white; /* White background */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: start;
            padding: 1rem;
        }
        .noise-canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1; 
            width: 100%;
            background: white; 
            border-radius: 0.5rem;
            margin-top: 1rem;
            padding: 0.5rem; 
            overflow: hidden; /* Contain canvas */
        }
        #mainCanvas:active {
            cursor: grabbing;
        }
        /* Style for the minimalist button */
        .minimal-button {
            border: 1px solid black;
            color: black;
            background-color: white;
            transition: background-color 0.15s, color 0.15s, transform 0.15s;
        }
        .minimal-button:hover {
            background-color: black;
            color: white;
        }
        .minimal-button:active {
            transform: scale(0.98);
        }
        /* Tailwind custom classes for the toggle switch */
        .toggle-switch-input:checked + .toggle-switch-slider {
            background-color: black;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        /* Custom range slider styling to make ghosts overlap cleanly */
        input[type=range] {
            -webkit-appearance: none; /* Hides the slider so that custom slider can be made */
            background: transparent; /* Otherwise white in Chrome */
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            margin-top: -4px; /* You need to specify a margin in Chrome, but in Firefox and IE it is automatic */
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb; /* gray-200 */
            border-radius: 2px;
        }
        
        /* Ghost specific thumb styles */
        .ghost-range::-webkit-slider-thumb {
            background: #666; /* Lighter for ghosts */
            pointer-events: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-start p-4 text-black">

    <!-- Header content -->
    <div id="header-content" class="flex flex-col items-center">
        <h1 class="text-3xl font-bold text-black mt-8 mb-2">random pixel grid deep zoom</h1>
        <p id="instruction-text" class="text-gray-700 max-w-xl text-center text-sm mb-4">
            try zooming into the white pixels
        </p>
    </div>

    <!-- Controls simplified -->
    <div id="controls" class="p-3 border border-black rounded-lg flex flex-wrap justify-center gap-4 items-center">
        
        <!-- Zoom Depth Display -->
        <div class="flex items-center space-x-2 text-lg font-mono p-1 px-3 border border-black rounded-md">
            <span>zoom depth:</span>
            <span id="zoom-depth-display" class="font-bold text-black">1</span>
        </div>

        <!-- Full Grid Size Display -->
        <div class="flex items-center space-x-2 text-lg font-mono p-1 px-3 border border-black rounded-md">
            <span>grid size:</span>
            <span id="grid-size-display" class="font-bold text-black">16x16</span>
        </div>

        <!-- Seed Input -->
        <div class="flex items-center space-x-2 text-lg font-mono p-1 px-3 border border-black rounded-md">
            <span>seed:</span>
            <input type="text" id="seed-input" value="12345" class="w-24 font-bold text-black outline-none bg-transparent text-right border-b border-gray-300 focus:border-black transition-colors" onchange="updateSeed()">
            <!-- Randomize Button -->
            <button onclick="randomizeSeed()" class="ml-2 p-1 hover:bg-gray-200 rounded-full transition-colors" title="Randomize Seed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </button>
        </div>
        
        <!-- White Chance Control -->
        <div class="flex items-center space-x-2 text-lg font-mono p-1 px-3 border border-black rounded-md">
            <span>white %:</span>
            
            <!-- Slider Container for Ghosts -->
            <div class="relative w-24 h-6 flex items-center">
                <!-- Ghost Ghost (Quarter Value, 25% Opacity) - Bottom Layer -->
                <input type="range" id="ghost-slider-2" min="0" max="100" value="12" disabled 
                       class="ghost-range absolute w-full h-full z-0 opacity-25 pointer-events-none">
                
                <!-- Ghost (Half Value, 50% Opacity) - Middle Layer -->
                <input type="range" id="ghost-slider-1" min="0" max="100" value="25" disabled 
                       class="ghost-range absolute w-full h-full z-10 opacity-50 pointer-events-none">
                
                <!-- Main Slider - Top Layer -->
                <input type="range" id="chance-slider" min="0" max="100" value="50" 
                       class="absolute w-full h-full z-20 cursor-pointer accent-black" 
                       oninput="updateChanceFromSlider()">
            </div>

            <input type="number" id="chance-input" value="50" min="0" max="100" class="w-12 font-bold text-black outline-none bg-transparent text-right border-b border-gray-300 focus:border-black transition-colors" onchange="updateChanceFromInput()">
        </div>

        <!-- Experimental Zoom Toggle Switch -->
        <div class="flex items-center space-x-3 text-sm">
            <label for="experimental-zoom-toggle" class="font-semibold text-gray-700 select-none">Experimental Zoom</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="experimental-zoom-toggle" id="experimental-zoom-toggle" class="toggle-switch-input absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" onchange="toggleExperimentalMode()">
                <label for="experimental-zoom-toggle" class="toggle-switch-slider block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>
        
        <button onclick="resetView()" 
                class="minimal-button px-4 py-1.5 font-semibold rounded-md text-base">
            reset view
        </button>
    </div>

    <div class="noise-canvas-container">
        <!-- Canvas size will be set dynamically in JavaScript -->
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        // --- Setup & Constants ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const zoomDepthDisplay = document.getElementById('zoom-depth-display');
        const gridSizeDisplay = document.getElementById('grid-size-display'); 
        const instructionText = document.getElementById('instruction-text');
        const seedInput = document.getElementById('seed-input');
        const chanceSlider = document.getElementById('chance-slider');
        const chanceInput = document.getElementById('chance-input');
        const ghostSlider1 = document.getElementById('ghost-slider-1');
        const ghostSlider2 = document.getElementById('ghost-slider-2');

        let DISPLAY_SIZE; 
        const INITIAL_GRID_N = 16;
        const INITIAL_GRID_SIZE = INITIAL_GRID_N * INITIAL_GRID_N; // 256 cells
        
        // --- MODIFIED: Increased rendering detail threshold from 8 to 16 ---
        // DETAIL_THRESHOLD controls when we stop subdividing recursively. 
        const DETAIL_THRESHOLD = 16; 

        // --- MODIFIED: Increased swapping threshold from 256 to 512 ---
        // SWAP_THRESHOLD controls the zoom level that triggers a full context swap in experimental mode.
        // The swap now occurs when a single cell takes up 512 / 16 = 32 times the initial screen width.
        const SWAP_THRESHOLD = 512; 

        // Standard Zoom Cap (Float precision limit)
        const MAX_FLOAT_ZOOM = 10000000000000; 

        // --- State Variables ---
        let mapData = []; // Root 16x16 grid
        let currentSeed = 12345;
        let whiteChance = 0.5; // 0.0 to 1.0
        
        // Shared View State
        let zoomLevel = 1; 
        let offsetX = 0;
        let offsetY = 0;
        
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // Experimental Mode State
        let useExperimentalZoom = false; 
        let pathStack = []; 
        
        // Tracks max depth rendered for display
        let maxVisibleDepth = 1; 

        // --- Deterministic Randomness ---

        function generateChildSeed(parentSeed, index) {
            var t = parentSeed ^ (index + 0x9E3779B9);
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t = Math.imul(t ^ (t >>> 7), t | 61);
            return (t >>> 0);
        }

        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        function createCell(seed) {
            const rng = mulberry32(seed);
            const color = rng() < whiteChance ? 255 : 0;
            return {
                color: color,
                subgrid: null,
                seed: seed
            };
        }

        function initializeMap() {
            mapData = [];
            for (let i = 0; i < INITIAL_GRID_SIZE; i++) {
                const cellSeed = generateChildSeed(currentSeed, i);
                mapData.push(createCell(cellSeed)); 
            }
        }
        
        function populateSubgrid(cell) {
            cell.subgrid = [];
            for (let j = 0; j < INITIAL_GRID_SIZE; j++) {
                const childSeed = generateChildSeed(cell.seed, j);
                cell.subgrid.push(createCell(childSeed));
            }
        }

        function getGridFromPath(path) {
            let currentGrid = mapData;
            for (let i = 0; i < path.length; i++) {
                const index = path[i];
                let cell = currentGrid[index];
                if (cell.subgrid === null) {
                    populateSubgrid(cell);
                }
                currentGrid = cell.subgrid;
            }
            return currentGrid;
        }

        // --- Rendering Logic ---

        /**
         * Recursive grid drawer.
         * Added skipIndex to prevent drawing the cell that we are about to draw in higher detail on top.
         */
        function drawRecursiveGrid(grid, drawX, drawY, currentSize, currentDepth, skipIndex = -1) {
            if (drawX + currentSize < 0 || drawY + currentSize < 0 || 
                drawX > DISPLAY_SIZE || drawY > DISPLAY_SIZE) {
                return;
            }
            
            if (currentSize < 0.5) return;

            maxVisibleDepth = Math.max(maxVisibleDepth, currentDepth);

            const cellSize = currentSize / INITIAL_GRID_N;
            const gridLength = grid.length;
            
            // If we are at base grid and minimum zoom in standard mode, we don't need fancy recursion.
            const isBaseGridAndAtMinZoom = (!useExperimentalZoom && currentDepth === 1 && zoomLevel <= 1.001);

            for (let y = 0; y < INITIAL_GRID_N; y++) {
                for (let x = 0; x < INITIAL_GRID_N; x++) {
                    const index = y * INITIAL_GRID_N + x;
                    
                    // SKIP the cell that represents the next layer down
                    // (Because we will draw that layer on top with higher precision)
                    if (index === skipIndex) continue;

                    if (index >= gridLength) continue;

                    const cell = grid[index];
                    const cellDrawX = drawX + x * cellSize;
                    const cellDrawY = drawY + y * cellSize;

                    if (cellDrawX + cellSize < 0 || cellDrawY + cellSize < 0 ||
                        cellDrawX > DISPLAY_SIZE || cellDrawY > DISPLAY_SIZE) {
                        continue;
                    }

                    // Only subdivide if the cell is white AND the resulting pixel size is large enough
                    // (DETAIL_THRESHOLD is now 16)
                    if (cell.color === 255 && !isBaseGridAndAtMinZoom && cellSize >= DETAIL_THRESHOLD) {
                        if (cell.subgrid === null) {
                            populateSubgrid(cell);
                        }
                        drawRecursiveGrid(cell.subgrid, cellDrawX, cellDrawY, cellSize, currentDepth + 1);
                    } else {
                        const colorVal = cell.color;
                        ctx.fillStyle = `rgb(${colorVal}, ${colorVal}, ${colorVal})`;
                        ctx.fillRect(
                            Math.floor(cellDrawX), 
                            Math.floor(cellDrawY), 
                            Math.ceil(cellSize + 0.5), 
                            Math.ceil(cellSize + 0.5)
                        );
                    }
                }
            }
        }

        function drawCanvas() {
            if (DISPLAY_SIZE === undefined) return;

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, DISPLAY_SIZE, DISPLAY_SIZE);

            if (useExperimentalZoom) {
                // EXPERIMENTAL MODE: Ancestor Rendering
                
                let renderQueue = [];
                
                // 1. Start with Tip (Current View)
                let currentGrid = getGridFromPath(pathStack);
                let currentSize = DISPLAY_SIZE * zoomLevel;
                let currentX = offsetX;
                let currentY = offsetY;
                let currentDepth = pathStack.length + 1;
                
                // Push Tip to queue (this draws last, on top)
                renderQueue.push({ 
                    grid: currentGrid, 
                    x: currentX, 
                    y: currentY, 
                    size: currentSize, 
                    depth: currentDepth,
                    skipIndex: -1 
                });

                // 2. Walk up the stack to find ancestors
                let tempSize = currentSize;
                let tempX = currentX;
                let tempY = currentY;

                // Iterate backwards from parent of tip
                for (let i = pathStack.length - 1; i >= 0; i--) {
                    let childIndex = pathStack[i]; // The index of the child within this parent
                    let cx = childIndex % 16;
                    let cy = Math.floor(childIndex / 16);
                    
                    // Calculate Parent's dimensions based on Child's
                    tempSize *= 16; 
                    tempX = tempX - cx * (tempSize / 16);
                    tempY = tempY - cy * (tempSize / 16);
                    
                    // Get Parent Grid
                    let parentGrid = getGridFromPath(pathStack.slice(0, i));
                    
                    // Add to front of queue (draw earlier, underneath)
                    renderQueue.unshift({ 
                        grid: parentGrid, 
                        x: tempX, 
                        y: tempY, 
                        size: tempSize,
                        depth: i + 1,
                        skipIndex: childIndex // Tell parent NOT to draw the child block
                    });
                    
                    if (tempSize > 1e10) break; 
                }
                
                // 3. Render All Layers
                // IMPORTANT: Reset maxVisibleDepth based on the logical stack depth base,
                // then let drawing update it to the actual pixel detail depth.
                maxVisibleDepth = pathStack.length + 1; 
                
                renderQueue.forEach(item => {
                    drawRecursiveGrid(item.grid, item.x, item.y, item.size, item.depth, item.skipIndex);
                });

            } else {
                // Standard Mode
                maxVisibleDepth = 1;
                drawRecursiveGrid(mapData, offsetX, offsetY, DISPLAY_SIZE * zoomLevel, 1);
            }

            updateZoomDisplay();
        }

        // --- Smart Swapping Engine (Experimental Mode) ---

        function enforceStackConstraints() {
            if (!useExperimentalZoom) return;

            // 1. Zoom In Threshold (SWAP_THRESHOLD is now 512)
            while (zoomLevel >= SWAP_THRESHOLD) {
                const centerX = DISPLAY_SIZE / 2;
                const centerY = DISPLAY_SIZE / 2;

                const gridX = (centerX - offsetX) / (DISPLAY_SIZE * zoomLevel) * 16;
                const gridY = (centerY - offsetY) / (DISPLAY_SIZE * zoomLevel) * 16;

                const cx = Math.floor(gridX);
                const cy = Math.floor(gridY);

                if (cx >= 0 && cx < 16 && cy >= 0 && cy < 16) {
                    const index = cy * 16 + cx;

                    // Check if target is white to prevent zooming into darkness
                    const currentGrid = getGridFromPath(pathStack);
                    const targetCell = currentGrid[index];

                    if (targetCell.color !== 255) {
                         break;
                    }

                    pathStack.push(index);
                    zoomLevel /= 16;

                    offsetX = offsetX + (cx * DISPLAY_SIZE * zoomLevel);
                    offsetY = offsetY + (cy * DISPLAY_SIZE * zoomLevel);

                } else {
                    break; 
                }
            }

            // 2. Zoom Out Threshold
            while (zoomLevel < 1 && pathStack.length > 0) {
                const childIndex = pathStack.pop();
                const cx = childIndex % 16;
                const cy = Math.floor(childIndex / 16);

                const oldZoom = zoomLevel; 
                zoomLevel *= 16;

                offsetX = offsetX - (cx * DISPLAY_SIZE * oldZoom);
                offsetY = offsetY - (cy * DISPLAY_SIZE * oldZoom);
            }
        }

        // --- Interaction Handlers ---

        function randomizeSeed() {
            const newSeed = Math.floor(Math.random() * 1000000);
            seedInput.value = newSeed;
            updateSeed();
        }

        function updateSeed() {
            const val = seedInput.value;
            let seedNum = parseInt(val);
            if (isNaN(seedNum)) {
                seedNum = 0;
                for (let i = 0; i < val.length; i++) {
                    seedNum = ((seedNum << 5) - seedNum) + val.charCodeAt(i);
                    seedNum |= 0; 
                }
            }
            currentSeed = seedNum;
            resetView();
        }

        function updateChanceFromSlider() {
            const val = chanceSlider.value;
            whiteChance = val / 100;
            chanceInput.value = val;
            
            ghostSlider1.value = val / 2;
            ghostSlider2.value = val / 4;
            
            resetView();
        }

        function updateChanceFromInput() {
            let val = parseInt(chanceInput.value);
            if (val < 0) val = 0;
            if (val > 100) val = 100;
            chanceInput.value = val;
            chanceSlider.value = val;
            whiteChance = val / 100;
            
            ghostSlider1.value = val / 2;
            ghostSlider2.value = val / 4;
            
            resetView();
        }

        function updateZoomDisplay() {
            // Use actual rendered depth for both modes
            const depth = maxVisibleDepth; 
            zoomDepthDisplay.textContent = depth;

            if (depth <= 10) { 
                const sideLength = Math.pow(16, depth);
                const formatter = new Intl.NumberFormat('en-US');
                const formattedLength = formatter.format(sideLength);
                gridSizeDisplay.textContent = `${formattedLength}x${formattedLength}`;
            } else {
                const sideLength = `16^${depth}`;
                gridSizeDisplay.textContent = `${sideLength}x${sideLength}`;
            }
        }

        function toggleExperimentalMode() {
            const checkbox = document.getElementById('experimental-zoom-toggle');
            useExperimentalZoom = checkbox.checked;
            resetView();
        }

        function resetView() {
            zoomLevel = 1;
            offsetX = 0;
            offsetY = 0;
            pathStack = [];
            initializeMap(); 
            maxVisibleDepth = 1; 
            drawCanvas();
        }

        function handleResize() {
            const headerHeight = document.getElementById('header-content').offsetHeight;
            const controlsHeight = document.getElementById('controls').offsetHeight;
            const bodyPadding = 32; 
            const marginBuffer = 30; 
            const availableHeight = window.innerHeight - headerHeight - controlsHeight - bodyPadding - marginBuffer; 
            const availableWidth = window.innerWidth - bodyPadding - marginBuffer; 
            const newSize = Math.floor(Math.min(availableWidth, availableHeight));

            canvas.width = newSize;
            canvas.height = newSize;
            DISPLAY_SIZE = newSize;
            drawCanvas();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // --- Unified Input Logic ---

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const isZoomingIn = e.deltaY < 0;
            const zoomFactor = isZoomingIn ? 1.1 : 0.9; 
            const newZoomLevel = zoomLevel * zoomFactor;
            
            let finalZoomLevel = newZoomLevel;
            let finalZoomFactor = zoomFactor;

            if (!useExperimentalZoom) {
                if (isZoomingIn && finalZoomLevel > MAX_FLOAT_ZOOM) {
                    finalZoomLevel = MAX_FLOAT_ZOOM;
                    finalZoomFactor = MAX_FLOAT_ZOOM / zoomLevel;
                } else if (!isZoomingIn && finalZoomLevel < 1) {
                    finalZoomLevel = 1;
                    finalZoomFactor = 1 / zoomLevel;
                }
            }

            const pos = getMousePos(e);
            offsetX = pos.x - (pos.x - offsetX) * finalZoomFactor;
            offsetY = pos.y - (pos.y - offsetY) * finalZoomFactor;
            zoomLevel = finalZoomLevel;

            if (useExperimentalZoom) {
                enforceStackConstraints();
            }

            if (!useExperimentalZoom && zoomLevel === 1) { 
                offsetX = 0; offsetY = 0; 
            }
            
            drawCanvas();
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            const pos = getMousePos(e);
            lastX = pos.x;
            lastY = pos.y;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const pos = getMousePos(e);
            offsetX += pos.x - lastX;
            offsetY += pos.y - lastY;
            lastX = pos.x;
            lastY = pos.y;
            drawCanvas();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('touchstart', (e) => {
            if(e.touches.length === 1) {
                isDragging = true;
                const pos = getMousePos(e);
                lastX = pos.x;
                lastY = pos.y;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if(isDragging && e.touches.length === 1) {
                e.preventDefault(); 
                const pos = getMousePos(e);
                offsetX += pos.x - lastX;
                offsetY += pos.y - lastY;
                lastX = pos.x;
                lastY = pos.y;
                drawCanvas();
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        window.onload = function() {
            handleResize();
            window.addEventListener('resize', handleResize);
            updateChanceFromSlider(); 
            canvas.style.cursor = 'grab'; 
            drawCanvas();
        }

    </script>
</body>
</html>
